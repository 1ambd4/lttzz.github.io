---
title: "408选手复健计划"
date: 2021-01-21T09:30:15+08:00
lastmod: 2021-01-21T09:30:15+08:00
draft: false
keywords: []
description: ""
tags: ["408"]
categories: []
author: "lttzz"

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: true
postMetaInFooter: false
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: true
mathjaxEnableSingleDollar: true
mathjaxEnableAutoNumber: true

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams: 
  enable: false
  options: ""

---

不能再摸鱼啦。~~麻了，remake了。~~

<!--more-->

# 0x00 复健计划

- [ ] 狗灰408视频 ~~王道俺是真不想看到了~~
- [ ] 狗灰复试视频
- [ ] Linux C编程一站式学习
- [ ] csapp
- [ ] sicp
- [ ] cn:atda
- [ ] lubuladong算法小抄
- [ ] Vim实用技巧
- [ ] 编码：隐匿在计算机软硬件背后的语言
- [ ] 计算机系统基础_袁春风
- [ ] 计算机网络实验
- [ ] 操作系统实验
- [ ] 数据库原理与应用——MySQL从入门到实战

# 0x01 数据结构

# 0x02 计算机组成原理

# 0x03 操作系统

# 0x04 计算机网络

## 资料

教材：[计算机网络：自顶向下方法](https://book.douban.com/subject/26176870/)

视频：[【灰灰考研】计算机网络基础课/强化课](https://www.bilibili.com/video/BV1xT4y1j7AL)

配套资料：[Computer Networking：A Top-Down Approach](https://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/index.html)

RFC：[IETF Datatracker](https://datatracker.ietf.org/)

听闻计算机网络自顶向下方法第六版翻译够烂，好家伙，果不其然。

![0121_02](/Picbed/2021_01/0121_02.png)

## 绪论

本科老师讲计网第一课说网络总结下来一共八个字：分组交换，存储转发。

### 协议分层

![protocol layering](/Picbed/2021_01/0121_00.png)

分层一来迎合了模块化设计的理念，将服务和实现分离开，二来网络是用来实现互连互通的，不分层的话，中间的互联设备也需要实现上层用于数据处理部分的协议，而这部分协议其实是用不到的。

### Traceroute

[RFC1393](https://www.rfc-editor.org/rfc/rfc1393.txt)

算法思想：依次发TTL从1到n的分组，那么收到TTL为i的包TTL过期的即为第i跳。

![wireshark](/Picbed/2021_01/0121_03.png)

### 流量强度



{{% center %}}

![流量强度](/Picbed/2021_01/0121_01.png)

{{% /center %}}



王道计网编书的抄图把横坐标给漏了，愣是没懂咋突然冒出来 `x=1` 这条铅直渐近线，这儿 $La/R$ 即流量强度，可以理解为传输速率与传播速率之比，当传输速率大于传播速率时，等待队列会慢慢变满，新的分组到了会被直接丢弃，故而设计系统时流量强度不能大于1。

### 安全问题

> It is worth considering how the Internet got to be such an insecure place in the first place. The answer, in essence, is that the Internet was originally designed to be that way, based on the model of "a group of mutually trusting users attached to a transparent network" -- a model in which (by definition) there is no need for security.

吴翰清也曾在书里说过：网络本来是安全的，研究安全的人多了就不安全了。

## 物理层

## 数据链路层

## 网络层

## 传输层

## 应用层

### DNS

权限域名服务器

递归查询、迭代查询。

### FTP

主动模式下，使用熟知端口（21）建立控制连接，使用熟知端口（20）建立数据连接。

### TELNET

### WWW

HTTP/1.0 无状态，HTTP/1.1使用持续连接（默认流水线模式）。

状态码

+ 1xx：通知信息，如请求收到了或正在处理
+ 2xx：成功，操作被成功接收并处理
+ 3xx：重定向，表示要完成请求还要进一步的行动
+ 4xx：客户端错误，请求包含语法错误或无法完成请求
+ 5xx：服务器错误，服务器在处理请求的过程中发生了错误

### E-MAIL

#### SMTP

#### MIME

#### POP

Post Office Protocol

#### IMAP



# 0x05 Linux C编程一站式学习

## 0x00 前言

> 学习编程绝不是一件简单的事，尤其是对于零基础的初学者来说。大学的计算机专业有四年时间从零基础开始培养一个人，微积分、线代、随机、离散、组合、自动机、编译原理、操作系统、计算机组成原理等等一堆基础课，再加上C/C++、Java、数据库、网络、软件工程、计算机图形学等等一堆专业课，最后培养出一个能找到工作的学生。很遗憾这最后一条很多学校没有做好，来亚嵌培训的很多学生就是四年这么学过来的，但据我们考查他们的基础几乎为零，我不知道为什么。与之形成鲜明对比的是，只给我们四个月的时间，同样要求从零基础开始，最后培养出一个能找到工作的学生，而且还要保证他找到工作，这就是职业教育的特点。
>
> 为什么我说“只给我们四个月的时间”？我们倒是想教四年呢，但学时的长短我们做不了主，是由市场规律决定的。四年的任务要求四个月做好，要怎么完成这样一个几乎不可能的任务？有些职业教育给出的答案是“实用主义”，打出了“有用就学，没有用就不学”的口号，大肆贬低说大学里教的基础课都是过时的、无用的，只有他们教的技术才是实用的，这种炒作很不好，我认为大学里教的每一门课都是非常有用的，基础知识在任何时候都不会过时，倒是那些时髦的“实用技术”有可能很快就过时了。
>
> 四年的任务怎么才能用四个月做好？我们给出的答案是“优化”。现在大学里安排的课程体系最大的缺点就是根本不考虑优化。每个过来人都会有这样的感觉：大一大二学了好多数学课，却不知道都是干什么用的，为什么要学。连它有什么用都不知道怎么能有兴趣学好呢？然后到大三大四学专业课时，用到以前的知识了，才发现以前学的数学是多么有用，然而早就忘得一干二净了，考完试都还给老师了，回头重新学吧，这时候才发现很多东西以前根本没学明白，现在才真的学明白了，那么前两年的时间岂不是都浪费了？大学里的课程体系还有一个缺点就是不灵活，每门课必须占一个学期，必须由一个老师教，不同课程的老师之间没有任何沟通和衔接，其实这些课程之间是相互依赖的，把它们强行拆开是不符合人的认知规律的。比如我刚上大学的时候，大一上半学期就被逼着学C语言，其实C语言是一门很难的编程语言，不懂编译原理、操作系统和计算机体系结构根本不可能学明白，那半个学期自然就浪费掉了。当时几乎所有学校的计算机相关专业都是这样，大一上来就学C语言，有的学校更疯狂，上来就学C++，导致大多数学生都以为自己会C语言，但其实都是半吊子水平，到真正写代码的时候经常为一个Bug搞得焦头烂额，却没有机会再系统地学一遍C语言，因为在学校看来，C语言课早在大一就给你“上完了”，就像一顿饭已经吃完了，不管你吃饱没吃饱，不会再让你重吃一遍了。显而易见，如果要认真地对这些课程做优化，的确是有很多水份可以挤的。

> 学习的过程总是这样，初学者一开始接触的很多概念从严格意义上说是错的，但是很容易理解，随着一步步学习，在理解原有概念的基础上不断纠正，不断泛化（Generalize）。

> 在运用逻辑推理时一定要注意，不要把必要条件（Necessary Condition）当充分条件（Sufficient Condition）。

nju ics2020 pa reference里提到的，对了，这本[电子书](https://docs.huihoo.com/c/linux-c-programming/index.html)最后更新于2009.2.27。

## 0x01 C语言入门

### 程序的基本概念

形式语言（Formal language）有别于自然语言（Natural Language），是为了特定的应用而人为设计的语言，有严格的语法（Syntax）规则，语法规则有符号（Token）和结构（Structure）的规则构成，结构关注的是Token的排列方式。关于Token的规则成为词法（Lexical）规则，关于结构的规则称为语法（Grammar）规则。分析句子结构的过程成为解析（Parse），属于语义（Semantic）的范畴。

### 递归

leap of faith: If you take a leap of faith, you do something even though you are not sure it is right or will succeed.

> 如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，那么它就会是正确的，从而值得你相信它正确。
>
> 这么说好像有点儿玄，以阶乘函数为例在数学上严格证明一下factorial函数的正确性。刚才说了，factorial(n)的正确性依赖于factorial(n-1)的正确性，只要后者正确，在后者的结果上乘个n返回这一步显然也没有疑问，那么我们的函数实现就是正确的。因此要证明factorial(n)的正确性就是要证明factorial(n-1)的正确性，同理，要证明factorial(n-1)的正确性就是要证明factorial(n-2)的正确性，依此类推下去，最后是：要证明factorial(1)的正确性就是要证明factorial(0)的正确性。而factorial(0)的正确性不依赖于别的函数调用，它就是程序中的一个小的分支return 1;，这个1是我们根据阶乘的定义写的，肯定是正确的，因此factorial(1)的实现是正确的，因此factorial(2)也正确，依此类推，最后factorial(n)也是正确的。其实这就是在中学时学的数学归纳法（Mathematical Induction），用数学归纳法来证明只需要证明两点：Base Case正确，递推关系正确。写递归函数时一定要记得写Base Case，否则即使递推关系正确，整个函数也不正确。

递归这边和labuladong讲的很类似，都强调了信任。

### 使用gdb调试

| 命令                | 描述                                                   |
| ------------------- | ------------------------------------------------------ |
| backtrace（或bt）   | 查看各级函数调用及参数                                 |
| finish              | 连续运行到当前函数返回为止，然后停下来等待命令         |
| frame（或f） 帧编号 | 选择栈帧                                               |
| info（或i） locals  | 查看当前栈帧局部变量的值                               |
| list（或l）         | 列出源代码，接着上次的位置往下列，每次列10行           |
| list 行号           | 列出从第几行开始的源代码                               |
| list 函数名         | 列出某个函数的源代码                                   |
| next（或n）         | 执行下一行语句                                         |
| print（或p）        | 打印表达式的值，通过表达式可以修改变量的值或者调用函数 |
| quit（或q）         | 退出`gdb`调试环境                                      |
| set var             | 修改变量的值                                           |
| start               | 开始执行程序，停在`main`函数第一行语句前面等待命令     |
| step（或s）         | 执行下一行语句，如果有函数调用则进入到函数中           |
| break（或b） 行号          | 在某一行设置断点                         |
| break 函数名               | 在某个函数开头设置断点                   |
| break ... if ...           | 设置条件断点                             |
| continue（或c）            | 从当前位置开始连续运行程序               |
| delete breakpoints 断点号  | 删除断点                                 |
| display 变量名             | 跟踪查看某个变量，每次停下来都显示它的值 |
| disable breakpoints 断点号 | 禁用断点                                 |
| enable 断点号              | 启用断点                                 |
| info（或i） breakpoints    | 查看当前设置了哪些断点                   |
| run（或r）                 | 从头开始连续运行程序                     |
| undisplay 跟踪显示号       | 取消跟踪显示                             |
| watch                   | 设置观察点                                                   |
| info（或i） watchpoints | 查看当前设置了哪些观察点                                     |
| x                       | 从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量 |

## 0x02 C语言本质

### 整数

#### 1‘s Complement

负数用1的补码（1's Complement）表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。取1的补码就是把每个bit取反，所以1的补码也称为反码。但是0的表示不唯一。

00001000-00000100 → 00001000+(-00000100) → 00001000+11111011 → 00000011进1 → 高位进的1加到低位上去，结果为00000100

### 2’s Complement

2's Complement表示法规定：正数不变，负数先取反码再加1，减法转换成加法，忽略计算结果最高位的进位，不必加回到最低位上去。

## 0x03 Linux系统编程



# 0x06 编码：隐匿在计算机软硬件背后的语言

## 第一章 电筒密谈

如何背着父母和同样临街而住的小伙伴在深夜交谈呢？买只手电筒吧！

‘A’闪一下，‘B’闪两下，依次类推。

闪得太多有点累哎，而且，符号不好表示，没有符号感情甚至句意就不同了。试试摩斯电码吧！

![Morse code](/Picbed/2021_02/0201_00.png)

## 第二章 编码与组合

现在你学会了用摩斯电码发送信息，试图教会小伙伴如何看懂。发送（编码）有表可查，接收（解码）似乎没有呢。

仔细研究摩斯电码表，

# 0x07 计算机系统基础_袁春风

## 异常和中断

exception：

+ Fault：执行指令引起的异常事件，如溢出、缺页、堆栈溢出、访问超时等。
+ Trap：又称自愿中断，是预先安排的事件，如单步跟踪、断点、系统调用等。
+ Abort：硬故障事件，终止程序执行。

interrupt：



## 写时拷贝

## 地址转换

VA -> LA -> PA

cs:eip -> 代码段/数据段基地址+EA



## Kahan算法

kahan算法旨在通过将每一次浮点计算后的误差累积到下一次计算中来降低浮点数运算的不精确性，当然喽，这要求操作数不能相差太大。

``` c
#include <stdio.h>

int main(void)
{
    float sum0 = 0;
    float sum1 = 0;
    float c = 0, y = 0, t = 0;;
 
    // 直接累加
    for (int i = 0; i < 4e6; ++i)
    {
        sum0 += 0.1;
    }
    
    // kahan算法
    // c: 误差值累加和	y: 经过修正的操作数		t: 结果
    for (int i = 0; i < 4e6; ++i)
    {
        y = 0.1 - c;
        t = sum1 + y;
        c = (t - sum1) - y;
        sum1 = t;
    }

    printf("sum0 = %f\n", sum0);	// sum0 = 384524.781250
    printf("sum1 = %f\n", sum1);	// sum1 = 400000.000000

    return 0;
}
```



# 0x08 计算机网络实验

EduCoder：[计算机网络实验](https://www.educoder.net/paths/734)

完整的Socket描述：{Protocol, local_host, local_port, remote_host, remote_port}

## WEB 服务器编程实现

![socket communication process](/Picbed/2021_02/0205_00.png)

``` python
'''
socket(socket_family, socket_type, protocol=0)
socket_family:
	AF_INET		IPb4
	AF_INET6	IPv6
	AF_UNIX		Unix进程间通信
socket_type:
	SOCK_STREAM	提供面向连接、可靠的数据传输服务
	SOCK_DGRAM	提供无连接的服务
	SOCK_RAW	主要用于实现自定义协议或底层网络协议
'''
serverSocket = socket(AF_INET, SOCK_STREAM)

```

![server response](/Picbed/2021_02/0205_01.png)

``` python
 #import socket module
from socket import *

serverSocket = socket(AF_INET, SOCK_STREAM) 
#Prepare a sever socket 
serverSocket.bind(("127.0.0.1",2333))
serverSocket.listen(1)

#while True:
print('开始WEB服务...')
try:
        connectionSocket, addr = serverSocket.accept()
        message = connectionSocket.recv(1024) # 获取客户发送的报文
        
        #读取文件内容
        filename = message.split()[1]       
        f = open(filename[1:])
        outputdata = f.read();
        
        #向套接字发送头部信息
        header = ' HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n' % (len(outputdata))
        connectionSocket.send(header.encode())

        #发送请求文件的内容
        for i in range(0, len(outputdata)):
            connectionSocket.send(outputdata[i].encode())
        
        #关闭连接
        connectionSocket.close()
except IOError:             #异常处理
        #发送文件未找到的消息
        header = ' HTTP/1.1 404 not Found'
        connectionSocket.send(header.encode())
        #关闭连接
        connectionSocket.close()
#关闭套接字
serverSocket.close()
```

## UDP Ping程序实现

![UDP](/Picbed/2021_02/0205_02.png)

# 0x09 操作系统实验

EduCoder：[操作系统](https://www.educoder.net/paths/2104)

## 中断、异常和系统调用

### 实训2.1：外部中断

#### step5：

评测脚本有问题

``` bash
ps -ef | grep runtest | grep -v grep | awk '{print $2}' | xargs kill -9  >/dev/null 2>&1
ps -ef | grep bochs-term | grep -v grep | awk '{print $2}' | xargs kill -9  >/dev/null 2>&1
rm -rf /home/headless/os/linux-0.11-lab/images/rootimage-0.11.lock
cd /root/os/linux-0.11-lab/
export TERM=xterm
./runtest > /root/1.log 2>&1 &
sleep 10
#ps -ef | grep runtest | grep -v grep | awk '{print $2}' | xargs kill -9  >/dev/null 2>&1
#ps -ef | grep bochs-term | grep -v grep | awk '{print $2}' | xargs kill -9  >/dev/null 2>&1
rm -rf /home/headless/os/linux-0.11-lab/images/rootimage-0.11.lock
sleep 10
python3 /data/workspace/myshixun/step5/test5.py
```

要求每发生100次时钟中断打印一次规定格式字符，然鹅测试脚本没等到发生第一次100个时钟中断就跑完了，故sleep时间稍微改长一点即可，如

``` bash
11c11
< sleep 10
---
> sleep 30
```

### 实训2.3：系统调用

#### step1

一直过不了，

#### step2：命令ls执行的系统调用

``` bash
# 设置条件断点以及遇到断点时执行的命令
(gdb) b system_call if current->pid != 0
Breakpoint 3 at 0x7694
(gdb) commands 3
Type commands for breakpoint(s) 3, one per line.
End with a line saying just "end".
>p $eax
>p sys_call_table[$eax]
>end
```



# 0x10 数据库原理与应用

EduCoder：[数据库原理与应用——MySQL从入门到实战](https://www.educoder.net/paths/243)

![It's not that difficult to modify a Table](/Picbed/2021_02/0205_03.png)

~~好有趣的图片~~

## MySQL数据定义与操作实战

### 各种引号

字符串用双引号：""

### 主键约束

添加主键约束有两种方式：

+ 定义列的同时指定主键
+ 定义完所有的列之后指定主键

神奇的是，这两种方式创建的表略有不同

``` mysql
mysql> create table t_a(
    -> `id` int primary key,
    -> `name` varchar(32)
    -> );
Query OK, 0 rows affected (0.00 sec)

mysql> create table t_b(
    -> `id` int,
    -> `name` varchar(32),
    -> primary key(`id`)
    -> );
Query OK, 0 rows affected (0.01 sec)

-- 注意看被定义成主键的列的默认值
-- 所以一般来讲定义完所有的字段然后指定主键的方式好一些，可以同时设置字段值不为空
-- 并且定义完字段再指定主键可以使用联合主键
mysql> desc t_a;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(11)     | NO   | PRI | NULL    |       |
| name  | varchar(32) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql> desc t_b;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(11)     | NO   | PRI | 0       |       |
| name  | varchar(32) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

### MySQL基本操作

``` mysql
/*
CONSTRIANT:
	not null
	default
	unique
	primary key
	check
*/

-- 查看数据表详细结构
show create table TABLE_NAME\G;

-- 修改表名
alter table OLD_NAME rename NEW_NAME;

-- 修改字段名（字段类型可以和原来一样，但是别空着
alter table TABLE_NAME change OLD_COLUMN_NAME NEW_COLUMN_NAME NEW_COLUMN_TYPE;

-- 修改字段类型
alter table TABLE_NAME modify COLUMN_NAME COLUMN_TYPE;

-- 添加字段
alter table TABLE_NAME add NEW_COLUMN_NAME NEW_COLUMN_TYPE [CONSTRIANT] [first | after] COLUMN_NAME;

-- 删除字段
alter table TABLE_NAME drop COLUMN_NAME;


-- 修改字段的配列顺序
alter table TABLE_NAME modify COLUMN_NAME_1 COLUMN_TYPE_1 first|after COLUMN_NAME_2;

-- 删除外键约束
alter table TABLE_NAME drop foreign key FOREIGN_KEY_NAME;

-- 插入数据（一次插入多条在后面继续写就成
-- 不指明字段名的话，需要按序完整的填写字段值
insert into TABLE_NAME
(
    COLUMN_NAME_1,
    COLUMN_NAME_1,
    ...
    COLUMN_NAME_n,
)
values
(
    COLUMN_VALUE_!,
    COLUMN_VALUE_2,
    ...
    COLUMN_VALUE_n,
),
(
    COLUMN_VALUE_!,
    COLUMN_VALUE_2,
    ...
    COLUMN_VALUE_n,
)

-- 更新数据
update TABLE_NAME
set COLUMN_NAME_1=COLUMN_VALUE_1, COLUMN_NAME_2=COLUMN_VALUE_2
where CONDITION;

-- 删除数据
delete from TABLE_NAME
where CONDITION;
```

### 单表查询

``` mysql
-- 基本查询语句
-- as用于起别名
select COLUMN_NAME_1 [as NEW_COLUMN_NAME_1], COLUMN_NAME_2 [as NEW_COLUMN_NAME_2], ..., COLUMN_NAME_n [as NEW_COLUMN_NAME_n]
from TABLE_NAME;

-- 带IN关键字的查询
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
where COLUMN_NAME [not] in (COLUMN_VALUE_1, COLUMN_VALUE_2, ..., COLUMN_VALUE_n);

-- BETWEEN AND范围查询（闭区间
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
where COLUMN_NAME [not] between COLUMN_VALUE_! and COLUMN_VALUE_2;

-- LIKE字符匹配查询
-- % 匹配任意多个字符（0个也成
-- _ 匹配任意一个字符
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
where COLUMN_NAME like 'REG';

-- 筛掉重复数据（使用distinct关键字
select distinct COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
where CONDITION;

-- 多条件查询（使用and和or
-- and的优先级大于or
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
where
CONDITION_1 [and|or]
CONDITION_2 [and|or],
...
CONDITON_n;

-- 排序（使用order by
-- 默认升序（asc升序，desc降序
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
order by COLUMN_NAME [asc|desc];

-- 分组查询
-- 按照COLUMN_NAME分组，但只会显示每一组中的一条记录
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
group by COLUMN_NAME;

-- LIMIT限制查询结果数量
-- 显示(offset, offset+n]的记录
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME
limit [offset,] NUMBER;
```

### 连接查询

``` mysql
-- 注意连接查询条件语句用的on引出，而不是前面一直在用的where

-- 内连接查询
-- 从表1中取出每一条记录，去表2中按照限定条件匹配，只显示成功的，一般用作主外键关系间
-- inner可以省略
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME_1 [as NEW_COLUMN_NAME_!]
inner join TABLE_NAME_2 [as NEW_COLUMN_NAME_2]
on CONDITION;

-- 外连接查询
-- 从表1中取出每一条记录，去表2中按照限定条件匹配，成功的显示值，失败的显示NULL
-- 左外连接：在内连接的基础上，还包含表1中所有不符合条件的数据行，并在其中的表2列填写 NULL
-- 右外连接：在内连接的基础上，还包含表2中所有不符合条件的数据行，并在其中的表1列填写 NULL
select COLUMN_NAME_1, COLUMN_NAME_2, ..., COLUMN_NAME_n
from TABLE_NAME_1 [as NEW_COLUMN_NAME_!]
[left|right] outer join TABLE_NAME_2 [as NEW_COLUMN_NAME_2]
on CONDITION;
```

### 子查询

子查询大概就是嵌套select之类的。

``` mysql
-- ALL、ANY、SOME关键字
-- 用在对单记录值与某一组记录值进行比较时候，描述这一组记录值的整体属性
-- ALL 所有
-- ANY 任一
-- SOME ANY的别名（？？？

```

### 使用MySQL解决问题

#### 交换工资

``` mysql
/*
本关任务：给定一张 tb_Salary 表，如下所示，有 m = 男性 和 f = 女性的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。

id	name	sex	salary
1	Elon	f	7000
2	Donny	f	8000
3	Carey	m	6000
4	Karin	f	9000
5	Larisa	m	5500
6	Sora	m	500
要求只使用一句更新update语句，且不允许含有任何select语句完成任务。

预期输出：

+----+--------+-----+--------+
| id | name   | sex | salary |
+----+--------+-----+--------+
|  1 | Elon   | m   |   7000 |
|  2 | Donny  | m   |   8000 |
|  3 | Carey  | f   |   6000 |
|  4 | karin  | m   |   9000 |
|  5 | Larisa | f   |   5500 |
|  6 | Sora   | f   |    500 |
+----+--------+-----+--------+
*/

update tb_Salary
set sex =
    case
        when sex="m" then "f"
        else "m"
    end
;  

/*
case语法

SELECT
    case                       ###如果
    when sex='1' then '男'     ###sex='1'，则返回值'男'
    when sex='2' then '女'     ###sex='2'，则返回值'女'  
    else '其他'     ###其他的返回'其他’
    end                        ###结束
from   sys_user     ###整体理解： 在sys_user表中如果sex='1'，则返回值'男'如果sex='2'，则返回值'女' 否则返回'其他’
*/
```

#### 换座位

``` mysql
/*
小美是一所中学的信息科技老师，她有一张 tb_Seat座位表，平时用来储存学生名字和与他们相对应的座位 id。

tb_Seat表结构数据如下：

id	name
1	Elon
2	Donny
3	Carey
4	Karin
5	Larisa
现在小美想改变相邻俩学生的座位（若学生人数为奇数，则无需改变最后一位同学的座位），现在需要你编写SQL输出小美想要的的结果。

预期输出：

id   name
1    Donny
2    Elon
3    Karin
4    Carey
5    Larisa
*/

select 
if(id%2=0, id-1, if(id=(select max(id) from tb_Seat), id, id+1)) as id, name
from tb_Seat order by id;

/*
if(a, b, c)
if的语法像极了三目运算符，如
select if(sex='1','男','女') as sex from sys_user;
如果sex='1'则返回值'男' 否则返回值为'女'
*/
```

# 0x11 2022 大纲变动

![大纲变动](/Picbed/2021_11/1106_00.jpg)

## 计算机网络

新增：

+ VLAN 基本概念与基本原理
+ SDN 基本概念

删除：

+ 令牌环网的基本原理
+ HDLC 协议
+ 网桥的概念和基本原理

### VLAN 基本概念与基本原理

![传统以太网络](/Picbed/2021_11/1106_01.png)

一个典型的以太网拓扑，只有终端计算机和二层交换机，考虑 PC1 和 PC2 通信的过程，考虑极端的情况，PC2 刚刚接入此网络，那么数据帧流向如图所示，其中实线为有效流量，虚线为垃圾流量，垃圾流量占用带宽不说，还会造成安全问题。再说广播的问题，PC1 发广播帧，全网都能收到。交换机无法隔离广播域，正着说就是一个交换式网络是一个广播域，广播域越大（接入的设备越多），垃圾流量和安全问题的问题越严重。

用路由器？问题是，一来路由器比交换机贵，二来路由器端口比交换机少得多，再者，高一层实现会引入额外开销，总之就是用路由器高价低能。

故而引入VLAN，将一个规模较大的广播域在逻辑上划分成若干规模较小的广播域，只有在同一个 VLAN  中的设备才可以直接进行二层通信，交换机识别所属 VLAN 使用 IEEE 802.1Q 规定的在以太网数据帧中插入的4字节 VLAN TAG（说白了，实现识别/辨别/区分的思想就是添加冗余信息）。并且 VLAN TAG 的生命周期仅存在于交换机间，对终端主机透明。

![IEEE 802.1Q](/Picbed/2021_11/1106_02.png)

划分 VLAN 的方式有：

+ 基于接口（常用）
+ 基于MAC地址
+ 基于协议
+ 基于子网划分

VLAN 涉及的三种链路类型：

+ access（单 VLAN 流量）
+ trunk（多 VLAN 流量）
+ hyprid（华三私有）

### SDN 基本概念

SDN：Software Defined Network。

SDN 是一种新兴的控制与转发分离并可直接编程的网络框架。

## 操作系统

### 程序运行环境

#### CPU运行模式

内核模式、用户模式

#### 中断和异常的处理

#### 系统调用

#### 程序的链接和装入

#### 程序运行时内存映象与地址空间

### 操作系统结构

#### 分层

#### 模块化

#### 宏内核

#### 微内核

#### 外核

### 操作系统引导

### 虚拟机

### 线程的实现

### 进程和线程的组织与控制
