---
title: "设计模式"
date: 2021-06-30T14:26:57+08:00
lastmod: 2021-06-30T14:26:57+08:00
draft: false
keywords: []
description: ""
tags: []
categories: []
author: "lttzz"

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: true
postMetaInFooter: false
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: false
mathjaxEnableSingleDollar: false
mathjaxEnableAutoNumber: false

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams: 
  enable: false
  options: ""

---

设计模式。<!--more-->

# 0x00.0 资料

[refactoring.guru](https://refactoringguru.cn/design-patterns)

## 0x00 概念

模式是重复问题的解决方案的核心，这些问题都有共同的特征：稳定中有变化。某种模式中假定的稳定部分，就是此模式的缺点所在。

对于某一个设计模式的描述应当包括：意图、动机和结构，意图简单描述问题和解决方案，动机进一部解释问题并说明模式会如何提供解决方案，结构则展示模式的每个部分和他们之间的关系。

按照意图来分类的话，可分为：

+ 创建型模式：提供创建对象的机制，增加已有代码的灵活性和可复用性；
+ 结构型模式：介绍如何将对象和雷组装成较大的结构，并同时保持结构的灵活和高效；
+ 行为模式：负责对象间的高效沟通和职责委派。

# 0x00 Object Oriented Programming Principles

模式是遵循原则下的方案，所以学习设计模式之前先熟悉设计原则很有必要。

- [Single Responsibility Principle](https://deviq.com/principles/single-responsibility-principle)（单一职责原则） 
  - 一个类应该仅有一个引起它发生变化的原因
  - 变化的方向隐含着类的责任
- [Open-Closed Principle](https://deviq.com/principles/open-closed-principle)（开放封闭原则）
  - 对扩展开放，对修改封闭
- [Liskov Substitution Principle](https://deviq.com/principles/liskov-substitution-principle)（里氏替换原则）
  子类必须能够替换其基类，即subtype is a base type
- [Interface Segregation Principle](https://deviq.com/principles/interface-segregation)（接口隔离原则）
  接口应当小而完备
- [Dependence Inverse Principle](https://deviq.com/principles/dependency-inversion-principle)（依赖倒置原则）
  - 高层模块（稳定）不应依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。
  - 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。
    取首字母，即SOLID。

# 0x01 Template Method

初学设计模式好的方法是: refactoring to patterns，以防止变成拿着锤子的人，看什么都像钉子。重构的关键技法有：

- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合
- ......
  实际上就是处理好稳定部分与变化部分的关系。

## Why Template Method?

操作结构稳定的前提下，如何灵活应对子步骤的变化或晚期实现需求？

``` c++
// Library.cpp writed by library developer
class Library  {
public:
    void step1() { }

    void step3() { }

    void step5() { }
};

// Application.cpp writed by application developer
class Application {
public:
    bool step2() { }

    void step4() { }
};

int main(void)
{
    Library lib();
    Application app();

    lib.step1();
    if (app.step2()) {
        lib.step3();
    }
    for (int i = 0; i < 4; ++i) {
        app.step4();
    }
    lib.step5();

    return 0;
}
```

## How Tempate Method?

应用开发人员调用类库时，尽管数据逻辑各不相同，但业务逻辑是固定不变的，将业务逻辑抽象出来并进行良好的封装，有利用代码复用。

``` c++
// Library.cpp writed by library developer
class Library {
public:
    // 应用template method，封装稳定的业务逻辑
    void run()
    {
        step1();

        // 用虚函数的多态抵御变化
        if (step2()) {
            step3();
        }

        for (int i = 0; i < 4; ++i) {
            step4();
        }

        step5();
    }
    
protected:
    // 稳定部分
    void step1() { }
    void step3() { }
    void step5() { }

    // 变化部分
    virtual bool step2() = 0;
    virtual void step4() = 0;
};

// Application.cpp writed by application development
class Application : public Library {
public:
    // 子类重写实现
    virtual bool step2()
    {
        // do something
    }
    virtual bool step4()
    {
        // do something
    }
};

int main(void)
{
    Library *plib = new Application();
    plib->run();

    delete plib;    // after use plib
    return 0;
}
```

重构后的代码很好的体现了OOP的封装、继承和多态。对于应用开发人员，可以不再关心业务逻辑，而只着眼于数据逻辑。
Template Method是一种非常基础且常用的设计模式，在OOP中，使用虚函数的多态性应对变化，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。
看到Template Method定义，我最先想到的是各种开发框架，比如接触到的第一个开发框架scrapy，定义数据结构然后写写解析规则，爬虫就写好了，神奇。当然一直停留在用框架，而不深入框架的实现细节，会陷入“只见树木不见森林“的境地。
整理笔记的时候，忽然就想起了没看完的那本《程序员的自我修养》，猛然发现，抛开Template Method的实现机制（OOP中使用的是虚函数）来说，当写下`int main(void)`的时候，就被用了Template Method。再进一步，日常生活中处处都有Template Method的影子，或者说，Template Method来源于生活。

## What is Template Method?

定义一个操作中的算法的骨架（稳定），而将一些步骤（变化）延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义（重写）该算法的某些步骤。
![Template Method](/Picbed/2021_06/0630_00.png)


# 0x02 Strategy

## Why Strategy? 

如何解耦合算法和对象？

``` c++
// before.cpp
enum TexBase {
    CN_Tax,
    US_Tax,
    JP_Tax,
    GE_Tax,
};

class SalesOrder {
public:
    double calculate()
    {
        //...

        if (tax == CN_Tax) {
            // cn...
        } else if (tax == US_Tax) {
            // us...
        } else if (tax == JP_Tax) {
            // jp...
        } else if (tax == GE_Tax) {
            // ge
        }
    }

private:
    TaxBase tax;
    TaxBase tax;
};
```

分析设计模式的时候，要始终以发展的眼光看问题。比如说此时系统需要支持法国，那么枚举和类都需要做改动，违背了OCP。

## How Strategy?

``` c++
// after.cpp
class TaxStrategy {
public:
    virtual double calculate(const Context& context) = 0;
    virtual ~TaxStrategy() { }
};

class CNTax : public TaxStrategy {
public:
    virtual double calculate(const Context& context) {
        // cn...
    }
};
class USTax : public TaxStrategy {
public:
    virtual double calculate(const Context& context) {
        // us...
    }
};
class JPTax : public TaxStrategy {
public:
    virtual double calculate(const Context& context) {
        // jp...
    }
};
class GETax : public TaxStrategy {
public:
    virtual double calculate(const Context& context) {
        // ge...
    }
};

class SalesOrder {
public:
    SalesOrder(StrategyFactory *factory) {
        this->strategy = factory->getInstance();
    }
    ~SalesOrder() {
        delete this->strategy;
    }
    double calculate() {
        Context context();

        double val = strategy->calculate(context);;
    }
private:
    TaxStrategy *strategy;;
};
```

这不就是面向接口编程嘛！
当看到大量的“if-else”，要往Strategy上想。

## What is Strategy?

定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展）。
![Strategy](/Picbed/2021_06/0630_01.png)


# 0x03 Observer

## Why Observer?

事件通知/消息广播机制是如何实现的？演化过程又是如何？
比如说你在写一个文件分割器，或者文件下载器，此时提出需求要显示进度条。

``` c++
// MainForm.cpp
class MainForm: public Form {
public:
    void on_button_click()
    {
        string filepath = text_file_path->getText();
        int number = atoi(text_file_number->getText());

        FileSpliter spliter(filepath, number);

        spliter.split();
    }
private:
    TextBox *text_file_path;
    TextBox *text_file_number;
};

// FileSpliter.cpp
class FileSpliter {
public:
    FileSpliter(const string &filepath, int number, ProgressBar *progressbar) :
    m_file_path(filepath), m_file_number(number), m_progress_bar(progressbar)
    {   }

    void split()
    {
        for (int i = 0; i < number; ++i) {
            // split file

            if (m_progress_bar != nullptr) {
                m_progress_bar->set_value((i+1) / m_file_number);   // update progressbar
            }
        }
    }
    
private:
    string m_file_path;
    int m_file_number;

    ProgressBar *m_progress_bar;    // 具体的通知控件
}
```

很直接的方法是在类中增加一个成员变量，但是这违背了DIP，因为底层的文件分割类依赖了顶层的进度条类，当进度条类发生改变的时候，文件分割类有可能也得做相应的变动。那依赖于进度条的基类呢？也不是很好的选择，上转型后子类的成员和方法可能会无法访问。

## How Observer?

思考进度条类的作用，实际是当文件分割完成后通知进度条更新，重点是“通知”，而使用控件来承担此责任，过于detail了。
面向接口重构一下？

``` c++
// MainForm.cpp
// C++多继承比较推荐的方式是继承自一个基类，其余都只继承自接口
class MainForm: public Form , IProgress {
public:
    void on_button_click()
    {
        string filepath = text_file_path->getText();
        int number = atoi(text_file_number->getText());

        FileSpliter spliter(filepath, number, this);    // MainForm继承自IProgress接口，故传this即可

        spliter.split();
    }
    
    virtual void do_progress(float value)
    {
        progressbar->set_value(value);
    }

private:
    TextBox *text_file_path;
    TextBox *text_file_number;
    ProgressBar *progressbar;
};

// FileSpliter.cpp
class FileSpliter {
public:
    FileSpliter(const string &filepath, int number, IProgress *progress) :
    m_file_path(filepath), m_file_number(number), m_iprogress(progress)
    {   }

    void split()
    {
        for (int i = 0; i < number; ++i) {
            // split file

            if (m_progress_bar != nullptr) {
                m_iprogress->do_progress((i+1) / m_file_number);
            }
        }
    }
    
private:
    string m_file_path;
    int m_file_number;

    // ProgressBar *m_progress_bar;    // 具体的通知控件
    IProgress *m_iprogress;            // 抽象的通知机制
};

// IProgress.cpp
class IProgress {
public:
    virtual void do_progress(float value) = 0;
    virtual ~IProgress() { }
};
```

现在违背DIP的部分基本解决了，还存在的欠缺是目前通知的接收者只有一个，有时候可能无法满足需求，继续重构。

``` c++
// MainForm.cpp
// C++多继承比较推荐的方式是继承自一个基类，其余都只继承自接口
class MainForm: public Form , IProgress {
public:
    void on_button_click()
    {
        string filepath = text_file_path->getText();
        int number = atoi(text_file_number->getText());

        // FileSpliter spliter(filepath, numbers, this);    // MainForm继承自IProgress接口，故传this即可
        FileSpliter spliter(filepath, numbers);

        spliter.register(this);

        ConsoleNofiter console_notifer;
        spliter.register(console_notifer);

        spliter.split();
    }
    
    virtual void do_progress(float value)
    {
        progressbar->set_value(value);
    }

private:
    TextBox *text_file_path;
    TextBox *text_file_number;
    ProgressBar *progressbar;
};

// 另一个需要处理进度的类
class ConsoleNofiter : public IProgress {
public:
    virtual void do_progress(float value)
    {
        cout << "prosess: " << value << endl;
    }
};

// FileSpliter.cpp
class FileSpliter {
public:
    FileSpliter(const string &filepath, int number, IProgress *progress) :
    m_file_path(filepath), m_file_number(number)
    {   }

    void split()
    {
        for (int i = 0; i < number; ++i) {
            // split file

                notify((i+1) / m_file_number);
            }
        }
    }

    bool register(IProgress *progress) {
        m_iprogress_list.push_back(progress);
    }

    bool unregister(IProgress *progress) {
        m_iprogress_list.remove(progress);
    } 

protected:
    void notify(float value)
    {
        for (auto e : m_iprogress_list) {
            e->do_progress(value);
        }
    }
    
private:
    string m_file_path;
    int m_file_number;

    // ProgressBar *m_progress_bar;       // 具体的通知控件
    // IProgress *m_iprogress;            // 抽象的通知机制
    list<IProgress*> m_iprogress_list;    // 使用链表等维护Observer
};

// IProgress.cpp
class IProgress {
public:
    virtual void do_progress(float value) = 0;
    virtual ~IProgress() { }
};
```

目标发送通知时，无需指定观察者，通知会自动传播。观察者自行决定是否需要订阅通知，目标对象对此一无所知。也即Observer模式使得我们可以独立的改变目标和观察者，从而松耦合。

## What is Observer?

定义对象间的一种一对多（变化）的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
![Observer](/Picbed/2021_06/0630_02.png)


# 0x04 Decorator

## Why Decorator?

使用继承来扩展功能，会因为继承引入静态特质（相较于多态的动态而言），随着扩展功能的增多，各种子类的组合会导致子类数量的急剧增长。

``` c++
// 基类
class Stream {
public:
    virtual char read(int number) = 0;
    virtual void seek(int position) = 0;
    virtual bool write(char data) = 0;

    virtual ~Stream() { }
};

// 子类
class FileStream: public Stream {
public:
    virtual char read(int number) {
        // read stream
    }

    virtual void seek(int position) {
        // seek stream
    }

    virtual bool write(char data) {
        // write stream
    }

    virtual ~FileStream() {}
};
class NetworkStream: public Stream {
public:
    virtual char read(int number) {
        // read stream
    }

    virtual void seek(int position) {
        // seek stream
    }

    virtual bool write(char data) {
        // write stream
    }

    virtual ~NetworkStream() {}
};
class MemoryStream: public Stream {
public:
    virtual char read(int number) {
        // read stream
    }

    virtual void seek(int position) {
        // seek stream
    }

    virtual bool write(char data) {
        // write stream
    }

    virtual ~MemoryStream() {}
};

// 此时要对各种流支持加密操作
class CryptoFileStream: public FileStream {
public:
    virtual char read(int number) {
        // stream crypto
        FileStream::read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        FileStream::seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        FileStream::write(data);
    }

    virtual ~CryptoFileStream() {}
};
class CryptoNetworkStream: public NetworkStream {
public:
    virtual char read(int number) {
        // stream crypto
        NetworkStream::read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        NetworkStream::seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        NetworkStream::write(data);
    }

    virtual ~CryptoNetworkStream() {}
};
class CryptoMemoryStream: public MemoryStream {
public:
    virtual char read(int number) {
        // stream crypto
        MemoryStream::read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        MemoryStream::seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        MemoryStream::write(data);
    }

    virtual ~CryptoMemoryStream() {}
};

// 继续，对各种流支持缓存
class BufferedFileStream: public FileStream {
public:
    virtual char read(int number) {
        // stream buffered
        FileStream::read(number);
    }

    virtual void seek(int position) {
        // stream buffered
        FileStream::seek(position);
    }

    virtual bool write(char data) {
        // stream buffered
        FileStream::write(data);
    }

    virtual ~BufferedFileStream() {}
};
class BufferedNetworkStream: public NetworkStream {
public:
    virtual char read(int number) {
        // stream buffered
        NetworkStream::read(number);
    }

    virtual void seek(int position) {
        // stream buffered
        NetworkStream::seek(position);
    }

    virtual bool write(char data) {
        // stream buffered
        NetworkStream::write(data);
    }

    virtual ~BufferedNetworkStream() {}
};
class BufferedMemoryStream: public MemoryStream {
public:
    virtual char read(int number) {
        // stream buffered
        MemoryStream::read(number);
    }

    virtual void seek(int position) {
        // stream buffered
        MemoryStream::seek(position);
    }

    virtual bool write(char data) {
        // stream buffered
        MemoryStream::write(data);
    }

    virtual ~BufferedMemoryStream() {}
};

// 再来，同时支持加密和缓冲操作
class BufferedCryptoFileStream: public FileStream {
public:
    virtual char read(int number) {
        // stream buffered and crypto
        FileStream::read(number);
    }

    virtual void seek(int position) {
        // stream buffered and crypto
        FileStream::seek(position);
    }

    virtual bool write(char data) {
        // stream buffered and crypto
        FileStream::write(data);
    }

    virtual ~BufferedCryptoFileStream() {}
};
class BufferedCryptoNetworkStream: public NetworkStream {
public:
    virtual char read(int number) {
        // stream buffered and crypto
        NetworkStream::read(number);
    }

    virtual void seek(int position) {
        // stream buffered and crypto
        NetworkStream::seek(position);
    }

    virtual bool write(char data) {
        // stream buffered and crypto
        NetworkStream::write(data);
    }

    virtual ~BufferedCryptoNetworkStream() {}
};
class BufferedCryptoMemoryStream: public MemoryStream {
public:
    virtual char read(int number) {
        // stream buffered and crypto
        MemoryStream::read(number);
    }

    virtual void seek(int position) {
        // stream buffered and crypto
        MemoryStream::seek(position);
    }

    virtual bool write(char data) {
        // stream buffered and crypto
        MemoryStream::write(data);
    }

    virtual ~BufferedCryptoMemoryStream() {}
};
```

写完是写完了，总之是各种不舒服，完全就是复制粘贴（夸一下vim
子类的增长速度惊人，倘使对n个基类的子类做m个功能扩展，那么最后共计得到$1 + n + n * m!/2$个类，离谱。
那么如何重构代码，消除冗余呢？

## How Decorator?

为什么会出来这么多类呢？因为继承。
那如果不用继承呢？试试组合。
篇幅原因，仅拿CryptoXXXStream为例

``` c++
class CryptoFileStream {
public:
    CryptoFileStream(FileStream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoFileStream() {}

protected:
    FileStream *stream;     // 使用组合而不是继承
};
class CryptoNetworkStream {
public:
    CryptoNetworkStream(NetworkStream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoNetworkStream() {}

protected:
    NetworkStream *stream;      // 实际组合而不是继承
};
class CryptoMemoryStream {
public:
    CryptoMemoryStream(MemoryStream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoMemoryStream() {}

protected:
    MemoryStream *stream;       // 使用组合而不是继承
};
```

可以看到三个类区别仅仅在于成员变量类型的不同，但注意到它们都是同一个类的派生类，那么声明为基类类型。

``` c++
class CryptoFileStream {
public:
    CryptoFileStream(Stream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoFileStream() {}

protected:
    Stream *stream;     // 使用组合而不是继承
};
class CryptoNetworkStream {
public:
    CryptoNetworkStream(Stream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoNetworkStream() {}

protected:
    Stream *stream;      // 实际组合而不是继承
};
class CryptoMemoryStream {
public:
    CryptoMemoryStream(Stream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoMemoryStream() {}

protected:
    Stream *stream;       // 使用组合而不是继承
};
```

如此，除去类名，并无不同。

``` c++
class CryptoStream {
public:
    CryptoStream(Stream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoStream() {}

protected:
    Stream *stream;       // 使用组合而不是继承
};
```

从接口规范的角度考虑，可以让重构后的CryptoStream继承自Stream类。

``` c++
class CryptoStream: public Stream {
public:
    CryptoStream(Stream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoStream() {}

protected:
    Stream *stream;       // 使用组合而不是继承
};
```

同理，重构其他两种扩展操作。

``` c++
// 加密功能
class CryptoStream: public Stream {
public:
    CryptoStream(Stream *stream) : stream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoStream() {}

protected:
    Stream *stream;       // 使用组合而不是继承
};
// 缓存功能
class BufferedStream: public Stream {
public:
    BufferedStream(Stream *stream) : stream(stream) {
    
    }
    
    virtual char read(int number) {
        // stream buffered
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream buffered
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream buffered
        stream->write(data);
    }

    virtual ~BufferedStream() {}

protected:
    Stream *stream;       // 使用组合而不是继承
};
```

神奇的是，重构完并不是预想的支持三种扩展操作所以有三个类，而是仅有两个类。那即加密又缓存如何实现呢?

``` c++
// 重构前
BufferedCryptoFileStream *stream = new BufferedCryptoFileStream();

// 重构后
// 芜湖，java狂喜
Stream *stream = new BufferedStream(new CryptoStream(new FileStream()));
Stream *stream = new CryptoStream(new BufferedStream(new FileStream()));
```

至此，基本完成了重构的工作，但是如果在多几个扩展功能，比如解密、压缩、解压缩等等，会发现几个扩展功能类都有相似的代码结构，也就是子类里有同样的字段，应该将其放到父类里。但是，如果放到父类Stream里，那么Stream的其他子类，如FileStream、MemoryStream、NetworkStream也会自然继承到这个成员变量，是不合理的。故，定义一个中间层DecoratorStream。

``` c++
class DecoratorStream: public Stream {
public:
    DecoratorStream(Stream *Stream) : stream(stream) {
    
    }
    
    virtual char read(int number) = 0;

    virtual void seek(int position) = 0;

    virtual bool write(char data) = 0;

    virtual ~DecoratorStream() { }

protected:
    Stream *stream;       // 使用组合而不是继承
}
// 加密功能类继承自装饰器接口
class CryptoStream: public DecoratorStream {
public:
    CryptoStream(Stream *stream) : DecoratorStream(stream) {
    
    }

    virtual char read(int number) {
        // stream crypto
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream crypto
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream crypto
        stream->write(data);
    }

    virtual ~CryptoStream() {}
};
// 缓存功能类继承自装饰器接口
class BufferedStream: public DecoratorStream {
public:
    BufferedStream(Stream *stream) : DecoratorStream(stream) {
    
    }
    
    virtual char read(int number) {
        // stream buffered
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream buffered
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream buffered
        stream->write(data);
    }

    virtual ~BufferedStream() {}
};
// 压缩功能类继承自装饰器接口
class CompressedStream: public DecoratorStream {
public:
    CompressecdStream(Stream *stream) : DecoratorStream(stream) {
    
    }
    
    virtual char read(int number) {
        // stream compressed
        stream->read(number);
    }

    virtual void seek(int position) {
        // stream compressed
        stream->seek(position);
    }

    virtual bool write(char data) {
        // stream compressed
        stream->write(data);
    }

    virtual ~BufferedStream() {}
};
```

重构完是加法级别增长了，总数量$1 + n + 1 + M$。

## What is Decorator?

动态的给一个对象增加一些额外的职责，就增加功能而言，Decorator模式（组合）比生成子类（继承）更为灵活。

Decorator模式在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类拥有一个Component类的实例。
Decorator模式应用的要点在于解决“基类在多个方向上（子类上）扩展功能”，但一昧滥用继承导致“多子类衍生的多继承”问题。
![Decorator](/Picbed/2021_07/0701_00.png)


# 0x05 Bridge

## Why Bridge?

Decorator模式很好的解决了在一个纬度上多方向扩展的问题，那如果遇到多个纬度上多方向扩展的问题呢？

``` c++
class Messager {
public:
    virtual void login(string username, string password) = 0;
    virtual void send_message(string message) = 0;
    virtual void send_picture(Image image) = 0;

    virtual void play_sound() = 0;
    virtual void draw_shape() = 0;
    virtual void write_text() = 0;
    vritual void connect() = 0;
};

// 比如IM应用需要区分平台实现，不同平台又区分轻量版和完整版

// PC平台
class PCMessagerBase: public Messager {
public:
    virtual void play_sound() {
        // pc play sound
    }

    virtual void draw_shape() {
        // pc draw shape
    }

    virtual void write_text() {
        // pc write text
    }
};
class PCMessagerLite: public PCMessagerBase {
public:
    virtual void login(string username, string password) {
        // pc lite login
        PCMessagerBase::connect();
    }

    virtual void send_message(string message) {
        // pc lite send message
        PCMessagerBase::write_text();
    }

    virtual void send_picture(Image image) {
        // pc lite send picture
        PCMessagerBase::draw_shape();
    }
};
class PCMessager: public PCMessagerBase {
public:
    virtual void login(string username, string password) {
        // pc login
        PCMessagerBase::play_sound();
        PCMessagerBase::connect();
    }

    virtual void send_message(string message) {
        // pc send message
        PCMessagerBase::play_sound();
        PCMessagerBase::write_text();
    }

    virtual void send_picture(Image image) {
        // pc send picture
        PCMessagerBase::play_sound();
        PCMessagerBase::draw_shape();
    }
};

// Mobile平台
class MobileMessagerBase: public Messager {
public:
    virtual void play_sound() {
        // mobile play sound
    }

    virtual void draw_shape() {
        // mobile draw shape
    }

    virtual void write_text() {
        // mobile write text
    }
};
class MobileMessagerLite: public MobileMessagerBase {
public:
    virtual void login(string username, string password) {
        // mobile lite login
        MobileMessagerBase::connect();
    }

    virtual void send_message(string message) {
        // mobile lite send message
        MobileMessagerBase::write_text();
    }

    virtual void send_picture(Image image) {
        // mobile lite send picture
        MobileMessagerBase::draw_shape();
    }
};
class MobileMessager: public MobileMessagerBase {
public:
    virtual void login(string username, string password) {
        // mobile login
        MobileMessagerBase::play_sound();
        MobileMessagerBase::connect();
    }

    virtual void send_message(string message) {
        // mobile send message
        MobileMessagerBase::play_sound();
        MobileMessagerBase::write_text();
    }

    virtual void send_picture(Image image) {
        // mobile send picture
        MobileMessagerBase::play_sound();
        MobileMessagerBase::draw_shape();
    }
};
```

类的总数量：1 + n + m。
还是一直再用vim的yank、put和replace，说明设计一定是有问题的，感觉起来蛮像Decorator的，尝试应用。

## How Bridge?

``` c++
// 方便对比起见，将Lite版本放在一起
class PCMessagerLite {
public:
    // 余下的构造函数省略不写
    PCMessagerLite(Messager *messager) : messager(messager) {
    }

    virtual void login(string username, string password) {
        // pc lite login
        messager->connect();
    }

    virtual void send_message(string message) {
        // pc lite send message
        messager->write_text();
    }

    virtual void send_picture(Image image) {
        // pc lite send picture
        messager->draw_shape();
    }

private:
    Messager *messager;         // 一步到位，声明为Messager类型，余下同理
    // PCMessagerBase *messager;
};

class MobileMessagerLite {
public:
    virtual void login(string username, string password) {
        // mobile lite login
        messager->connect();
    }

    virtual void send_message(string message) {
        // mobile lite send message
        messager->write_text();
    }

    virtual void send_picture(Image image) {
        // mobile lite send picture
        messager->draw_shape();
    }

private:
    Messager *messager;
    // MobileMessagerBase *messager;
};


class PCMessager {
public:
    virtual void login(string username, string password) {
        // pc login
        messager->play_sound();
        messager->connect();
    }

    virtual void send_message(string message) {
        // pc send message
        messager->play_sound();
        messager->write_text();
    }

    virtual void send_picture(Image image) {
        // pc send picture
        messager->play_sound();
        messager->draw_shape();
    }

private:
    Messager *messager;
    // PCMessagerBase *messager;
};

class MobileMessager {
public:
    virtual void login(string username, string password) {
        // mobile login
        messager->play_sound();
        messager->connect();
    }

    virtual void send_message(string message) {
        // mobile send message
        messager->play_sound();
        messager->write_text();
    }

    virtual void send_picture(Image image) {
        // mobile send picture
        messager->play_sound();
        messager->draw_shape();
    }

private:
    Messager *messager;
    // MobileMessagerBase *messager;
};
```

XXMessagerLite是相同的，XXMessager也是，故合并。

``` c++
class MessagerLite {
public:
    virtual void login(string username, string password) {
        // mobile lite login
        messager->connect();
    }

    virtual void send_message(string message) {
        // mobile lite send message
        messager->write_text();
    }

    virtual void send_picture(Image image) {
        // mobile lite send picture
        messager->draw_shape();
    }

private:
    Messager *messager;
    // MobileMessagerBase *messager;
};


class MessagerComplete {
public:
    PCMessager(Messager *messager) : messager(messager) {
    }

    virtual void login(string username, string password) {
        // pc login
        messager->play_sound();
        messager->connect();
    }

    virtual void send_message(string message) {
        // pc send message
        messager->play_sound();
        messager->write_text();
    }

    virtual void send_picture(Image image) {
        // pc send picture
        messager->play_sound();
        messager->draw_shape();
    }

private:
    Messager *messager;
    // PCMessagerBase *messager;
};
```

``` c++
// before refactoring
PCMessagerLite = new PCMessagerLite();

// after refactoring
// 用的时候发现出问题了，PCMessagerBase()是抽象类，无法实例化。 
Messager messager = new MessagerLite(new PCMessagerBase());         // error
Messager messager = new MessagerComplete(new PCMessagerBase());     // error
```

让PCMessagerBase实现其余的方法？那不又回去了么。
解决方案是将基类Messager拆分。

``` c++
class Messager {
public:
    Messager (MessagerImp *imp) : messager_imp(imp) { }
    virtual void login(string username, string password) = 0;
    virtual void send_message(string message) = 0;
    virtual void send_picture(Image image) = 0;
    ~virtual Messager() { }
private:
    MessagerImp *messager_imp;
};

class MessagerImp {
public:
    virtual void play_sound() = 0;
    virtual void draw_shape() = 0;
    virtual void write_text() = 0;
    vritual void connect() = 0;
};

// PC平台
class PCMessagerImp: public MessagerImp {
public:
    virtual void play_sound() {
        // pc play sound
    }

    virtual void draw_shape() {
        // pc draw shape
    }

    virtual void write_text() {
        // pc write text
    }

    virtural void connect() {
        // pc connect
    };
};

// Mobile平台
class MobileMessagerImp: public MessagerImp {
public:
    virtual void play_sound() {
        // mobile play sound
    }

    virtual void draw_shape() {
        // mobile draw shape
    }

    virtual void write_text() {
        // mobile write text
    }

    virtural void connect() {
        // mobile connect
    };
};

// Lite版本
class MessagerLite {
public:
    virtual void login(string username, string password) {
        // mobile lite login
        messager_imp->connect();
    }

    virtual void send_message(string message) {
        // mobile lite send message
        messager_imp->write_text();
    }

    virtual void send_picture(Image image) {
        // mobile lite send picture
        messager_imp->draw_shape();
    }

private:
    // MessagerImp *messager_imp;       // lite和cmoplete都包含此成员变量，向上提至父类Messager中
    // MobileMessagerBase *messager;
};

// Complete版本
class MessagerComplete {
public:
    PCMessager(Messager *messager) : messager(messager) {
    }

    virtual void login(string username, string password) {
        // pc login
        messager_imp->play_sound();
        messager_imp->connect();
    }

    virtual void send_message(string message) {
        // pc send message
        messager_imp->play_sound();
        messager_imp->write_text();
    }

    virtual void send_picture(Image image) {
        // pc send picture
        messager_imp->play_sound();
        messager_imp->draw_shape();
    }

private:
    // MessagerImp *messager_imp;       // lite和cmoplete都包含此成员变量，向上提至父类Messager中
    // PCMessagerBase *messager;
};
```

至此，重构到了Bridge模式。

``` c++
// ok, fine.
Messager *messager = new MessagerLite(new MobileMessagerImp());
Messager *messager = new MessagerComplete(new MobileMessagerImp()); 
```

## What is Bridge?

将抽象部分（业务功能）与实现部分（平台实现）分离，使它们可以独立的变化。
Bridge模式使用对象间的组合接耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。有时候Bridge模式类似于多继承方案，但多继承方案往往违背SRP，复用性不如Bridge模式。
![Bridge](/Picbed/2021_07/0705_00.png)




# 0x06 Factory Method

## Why Factory Method?

``` c++
class ISpliter {
public:
    virtual void split() = 0;
    ~virtual ISpliter() { }
};

class FileSpliter: public ISpliter {
public:
    virtual void split()
    {
        // file split
    }
}

class PictureSpliter: public ISpliter {
public:
    virtual void split()
    {
        // picture split
    }
}

class VideoSpliter: public ISpliter {
public:
    virtual void split()
    {
        // video split
    }
}

class BinarySpliter: public ISpliter {
public:
    virtual void split()
    {
        // binary split
    }
}

// MainForm里使用Spliter
class MainForm: public Form {
public:
    void on_button_click()
    {
        // 等号左边是一个抽象接口，右边是实现类
        // 但这样的话，MainForm就依赖于具体了
        // 造成这种情况的原因是new过度依赖于实现细节
        // 是否可以绕开new创建对象呢？
        ISpliter *spliter = new FileSpliter();
        spliter->split();
    }
};
```

## How Factory Method?

``` c++
// C++对象可以创建在堆上，也可以在栈上，那么在栈上创建呢？
FileSpliter fs;
fs.split()
// 更糟糕了
```

还有没有其他方法创建对象呢？没了。
这是直接创建，那间接的呢，比如说创建一个对象然后返回？其实new也就是这个道理。

``` c++
class CreateFileSpliter {
public:
    ISpliter* create_spliter()
    {
        return new FileSpliter();
    }
};

class MainForm: public Form {
public:
    MainForm(CreateFileSpliter cfs) : cfs(cfs)
    {
        // ctor
    }
    ~MainForm()
    {
        delete cfs;
    }

    void on_button_click()
    {
        ISpliter *spliter = cfs.create_spliter();
        spliter.split();
    }
private:
    CreateFileSpliter cfs;
}
```

MainFrom不直接依赖于具体类了，好耶。可MainFrom依赖的CreateFileSpliter依赖具体类，还是间接依赖了具体类。那可怎么办呢，CreateFileSpliter同样也不能实例化抽象类。哎，抽象类？抽象类不就可以解决这儿的问题么，将返回对象的实现推迟到子类中去，在MainForm里放一个抽象指针，初始化的时候传入子类实例就好了呀。

``` c++
// 抽象工厂类
class IFactory {
public:
    virtual ISpliter* create_spliter() = 0;
    ~Virtual IFactory() { }
};

// 具体工厂类
class FileFactory: public IFactory {
public:
    virtual ISpliter* create_spliter()
    {
        return new FileSpliter();
    }
};
class PictureFactory: public IFactory {
public:
    virtual ISpliter* create_spliter()
    {
        return new PictureSpliter();
    }
};
class VideoFactory: public IFactory {
public:
    virtual ISpliter* create_spliter()
    {
        return new VideoSpliter();
    }
};
class BinaryFactory: public IFactory {
public:
    virtual ISpliter* create_spliter()
    {
        return new BinarySpliter();
    }
};

// 使用
class MainForm: public Form {
public:
    MainForm(IFactory *factory) : factory(factory)
    {
        // ctor
    }
    ~MainForm()
    {
        delete factory;
    }

    void on_button_click()
    {
        ISpliter *spliter = factory->create_spliter();
        spliter->split();
    }
    private
private:
    IFactory *factory;
};
```

## What is Factory Method?

定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟到子类。

在软件系统中，经常面临对象的创建工作，而由于需求的变化，需要创建的对象的具体类型也经常性的发生变化。工厂方法通过定义专用于创建对象的接口，采用面向对象的方法（虚函数），绕过常规的对象创建方法（new）,将对象的创建延迟到子类。同样，Factory Method也有其缺点，比如抽象工厂封装了相同的接口，势必要求不同的工厂保持相同的参数。

![Factory Method](/Picbed/2021_07/0706_00.png)


# 0x07  Abstract Fatory

## Why Abstract Factory?

在软件系统中，经常面临“一系列相互依赖的对象”的创建工作，同时，由于需求的变化，往往存在更多系列对象的创建工作。如何绕过常规的对象创建方法（new），提供一种封装机制来避免客户程序和“多系列具体对象创建工作”的紧耦合？

``` c++
// 若此时还需要增加对mysql、oracle等数据库的支持
class EmployeeDAO {
public:
    vector<Employee> getEmployees()
    {
        SqlConnection *connection = new SqlConnection();
        connection->connectionString("...");

        SqlCommand *command = new SqlCommand();
        command->commandText("...");
        command->setConnection(connection);

        SqlDataReader *reader = command->executeReader();
        while (reader->read()) {
            // ...
        }
    } 
};
```

## How Abstract Factory?

``` c++
// 抽象基类
class IConnection {
};
class ICommand {
};
class IReader {
};

// 实现类
class SqlConnection: public IConnection {
};
class SqlCommand: public ICommand {
};
class SqlReader: public IReader {
};

class OracleConnection: public IConnection {
};
class OracleCommand: public ICommand {
};
class OracleReader: public IReader {
};

class MysqlConnection: public IConnection {
};
class MysqlCommand: public ICommand {
};
class MysqlReader: public IReader {
};

// 工厂类
class IConnectionFactory {
public:
    virtual create_connection() = 0;
};
class ICommandFactory {
public:
    virtual craete_command() = 0;
};
class IReaderFactory {
public:
    virtual create_reader() = 0;
};

// 具体工厂类
class SqlConnectionFactory: public IConnectionFactory {
public:
    virtual create_connection()
    {
        // create sql server connection
    }
};
class SqlCommandFactory: public ICommandFactory {
public:
    virtual create_command()
    {
        // create sql server command
    }
};
class SqlReaderFactory: public IReaderFactory {
public:
    virtual create_reader()
    {
        // create sql server reader
    }
};

class OracleConnectionFactory: public IConnectionFactory {
public:
    virtual create_connection()
    {
        // create oracle connection
    }
};
class OracleCommandFactory: public ICommandFactory {
public:
    virtual create_command()
    {
        // create oracle command
    }
};
class OracleReaderFactory: public IFactory {
public:
    virtual create_reader()
    {
        // create oracle reader
    }
};

class MysqlConncectionFactory: public IConnectionFactory {
public:
    virtual create_connection()
    {
        // create mysql connection
    }
};
class MysqlCommandFactory: public ICommandFactory {
public:
    virtual create_command()
    {
        // create mysql command
    }
};
class MysqlReaderFactory: public IReaderFactory {
public:
    virtual create_reader()
    {
        // create mysql reader
    }
};

class EmployeeDAO {
public:
    EmployeeDAO(IConnectionFactory *connFactory, ICommandFactory *commFactory, IReaderFactory readFactory):
        connectionFactory(connFactory), commandFactory(commFactory), readerFactory(readFactory)
    {
    }
    vector<Employee> getEmployees()
    {
        // SqlConnection *connection = new SqlConnection();
        SqlConnection *connection = connectionFactory->create_connection();
        connection->connectionString("...");

        // SqlCommand *command = new SqlCommand();
        ICommand *command = commandFactory->create_command();
        command->commandText("...");
        command->setConnection(connection);

        // SqlDataReader *reader = command->executeReader();
        IDataReader *reader = command->executeReader();
        while (reader->read()) {
            // ...
        }
    } 
private:
    IConnectionFactory *connectionFactory;
    ICommandFactory *commandFactory;
    IReaderFactory *readerFactory;
};
```

照搬Factory Method，似乎解决了问题，但假使调用封装好的几个类的是不太高明的程序员呢？

``` c++
// EmployeeDAO里包含的三个工厂创建的实例是有关联性的，但是类内没有做任何验证EmployeeDAO dao = new EmployeeDAO(new SqlConnectionFactory(), new OracleCommandFactory(), new MysqlReaderFactory);
```

那么如何做呢？引起问题的原因是有关联的实例由不同的工厂方法创建，如果把一组实例的创建写到一起呢？

``` c++
// 工厂类class IFactory {    virtual create_connection() = 0;    virtual craete_command() = 0;    virtual create_reader() = 0;};// 具体工厂类class SqlFactory: public IFactory {    virtual create_connection()    {        // create sql server connection    }    virtual create_command()    {        // create sql server command    }    virtual create_reader()    {        // create sql server reader    }};class OracleFactory: public IFactory {    virtual create_connection()    {        // create oracle connection    }    virtual create_command()    {        // create oracle command    }    virtual create_reader()    {        // create oracle reader    }};class MysqlFactory: public IFactory {    virtual create_connection()    {        // create mysql connection    }    virtual create_command()    {        // create mysql command    }    virtual create_reader()    {        // create mysql reader    }};class EmployeeDAO {public:    EmployeeDAO(IFactory *factory) : factory(connFactory)    {    }    vector<Employee> getEmployees()    {        // SqlConnection *connection = new SqlConnection();        SqlConnection *connection = connectionFactory->create_connection();        connection->connectionString("...");        // SqlCommand *command = new SqlCommand();        ICommand *command = commandFactory->create_command();        command->commandText("...");        command->setConnection(connection);        // SqlDataReader *reader = command->executeReader();        IDataReader *reader = command->executeReader();        while (reader->read()) {            // ...        }    } private:    IFactory *factory;//    IConnectionFactory *connectionFactory;//    ICommandFactory *commandFactory;//    IReaderFactory *readerFactory;};// 解决EmployeeDAO dao = new EmployeeDAO(new SqlFactory());
```

许是举例不够好，把三个类塞到一起不也行？

## What is Abstract Factory?

提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。

将Factory Method再封装一层（具有依赖关系的打包到一起），就是Abstract Factory。

![Abstract Factory](/Picbed/2021_07/0710_00.png)


# 0x08  Prototype

## Why Prototype?

工厂模式很好的解决了多数情况下的对象创建问题，但如果希望创建的对象保有某些状态呢？

## How Prototype?

``` c++
// 将工厂类塞到抽象类中，工厂方法中调用类的拷贝构造函数class ISpliter {public:    virtual void split() = 0;    virtual ISpliter* clone() = 0;    virtual ~ISpliter() { }};class FileSpliter : public ISpliter {public:    virutal ISpliter* clone() {        return new FileSpliter(*this);    }};class PictureSpliter : public ISpliter {public:    virtual ISpliter* clone() {        return new PictureSpliter(*this);    }}// ...class MainForm : public Form {public:    MainForm(ISpliter* prototype) : prototype(prototype) {        }    void on_button_click() {        // 用原型拷贝构造        ISpliter *spliter = prototype->clone();        spliter->split();    }private:};
```

## What is Prototype?

使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

当需要构建的对象涉及到大量状态，而用工厂方法实现起来复杂时，可以选用Prototype。

![Prototype](/Picbed/2021_07/0715_00.png)





