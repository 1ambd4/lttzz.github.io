---
title: "算法"
date: 2021-04-08T19:10:31+08:00
lastmod: 2021-04-08T19:10:31+08:00
draft: false
keywords: []
description: ""
tags: []
categories: []
author: "lttzz"

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: true
postMetaInFooter: false
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: true
mathjaxEnableSingleDollar: true
mathjaxEnableAutoNumber: false

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams: 
  enable: false
  options: ""

---

<!--more-->

# 数据结构

## 字典树 Trie

Trie 其实就是一个26叉树，每个结点维护一个词尾标记。

``` c++
class Trie {
public:
    Trie() : child(26), is_word(false) { }

    void insert(string word)
    {
        Trie *node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->child[ch] == nullptr) {
                node->child[ch] = new Trie();
            }
            node = node->child[ch];
        }
        node->is_word = true;
    }

    bool search(string word)
    {
        Trie *result = search_prefix(word);
        return result != nullptr && result->is_word;
    }

  	// 查找已经插入的 word 中是否有以 prefix 为前缀
    bool start_with(string prefix)
    {
        return search_prefix(prefix) != nullptr;
    }

private:
    vector<Trie*> child;
    bool is_word;

    Trie* search_prefix(string prefix)
    {
        Trie *node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (node->child[ch] == nullptr) {
                return nullptr;
            }
            node = node->child[ch];
        }
        return node;
    }
};
```

# 分治

# 搜索

+ [0167](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)
+ [0240](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

## 二分

![](/Picbed/2021_10/1019_00.png)

``` c++
// 普通二分
int search(vector<int>& nums, int target)
{
  	int left = 0, right = nums.size()-1;
  	
  	while(left <= right) {
      	int mid = left + (right - left) / 2;
      	if (nums[mid] == target) {
          	return mid;
        } else if (nums[mid] > target) {
          	right = mid - 1;
        } else if (nums[mid] < target) {
          	left = mid + 1;
        }
    }
  	
  	return -1;
}


// 二分最左边界
int search(vector<int>& nums, int target)
{
    int left = 0, right = nums.size()-1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
          	// 唯一区别就是查找成功的时候，不直接返回而是收束边界
            right = mid - 1;
        } else if (nums[mid] > target) {
           right = mid - 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        }
    }

  	// 返回前做一下检查
    if (left >= nums.size() || nums[left] != target) {
        return -1;
    }
    return left;
}


// 二分最右边界
```



# 动态规划

## 最长递增子序列（LIS）

[最长上升子序列 (LIS) 详解+例题模板 (全)](https://blog.csdn.net/lxt_Lucia/article/details/81206439)

### 动态规划（$O(n^{2})$）

先思考暴力解法，

dp[i]定义为以i为下标的元素的LIS，对于当前元素来说，如果它比它前面的元素大，符合那么状态转移方程为：
$$
dp[i] = max(dp[i], dp[j]+1), \qquad for  \quad j < i
$$


``` c++
#include <iostream>

using namespace std;

constexpr int MAX = 1e5 + 10;
int dp[MAX], result = 1;
long nums[MAX];

int longest_increasing_subsequence(int n) {
    fill(dp, dp+MAX, 1);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j]+1);
            }
        }
    }
    // c++17(O(n))
    return dp[distance(dp, max_element(dp, dp+n))];
}

int main(void) {
    int n = 0;
    cin >> n;    
    for (int i = 0; i < n; ++i) {
        scanf("%ld", &nums[i]);
    }
    cout << longest_increasing_subsequence(n) << endl;
    return 0;
}
```



### 二分搜索（$O(n \log n)$）

### 树状数组（$O(n \log n)$）



# 位运算

## 奇偶判定

``` c++
if (n & 1) {
  	// odd
} else {
  	// even
}
```

## 取第m位

``` c++
(n>>(m-1))&1
```

## 将二进制表示的最低位的1置0

``` c++
n & (n-1)
```

# labuladong 的算法小抄

## 算法框架

### BFS

BFS空间开销大，DFS时间开销大。

#### 二叉树最小深度

[Leetcode 0111](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)，BFS找第一个左右儿子都空的。

``` c++
// 随手一写就是经典的错误，错误的原因在于错误的提前更新了 ans
// 或者说，根本就一点都不对，因为每次并没有遍历完所有相邻结点，这么写就不是BFS
// 错误写法
int _minimum_depth(TreeNode *root)
{
    if (root == nullptr) return 0;
    queue<TreeNode*> q;
    q.push(root);
    int ans = 1;
    while (!q.empty()) {
        TreeNode *cur = q.front();
        q.pop();
        if (cur->left == nullptr && cur->right == nullptr) {
            return ans;
        }
        if (cur->left != nullptr) {
            q.push(cur->left);
        }
        if (cur->right != nullptr) {
            q.push(cur->right);
        }
        ans++;
    }
}

// 正确写法
int minimum_depth(TreeNode *root)
{
    if (root == nullptr)  return 0;
    queue<TreeNode*> q;
    q.push(root);
    int ans = 1;
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            TreeNode *cur = q.front();
            q.pop();
            if (cur->left == nullptr && cur->right == nullptr) {
                return ans;
            }
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
        ans++;
    }

    return -1;
}

// 当然，也可以每个结点维护一个 depth，这样就不存在误更新的情况
```

# Easy

## 前缀和

离线区间和查询

## 差分数组

在线区间增减。

累加差分数组可以得到原数组，对于整个区间的整体增减，由于累加操作的传递性，等效于对左右两个边界的diff值增减。

# Medium

## 滑动窗口

右扩找可行解，左缩优化当前解为最优解，因而在左缩的过程中更新解。

## 单调栈

``` c++
// [2,1,2,4,3] -> [4,2,4,-1,-1]
vector<int> next_greater_element(vector<int>& nums)
{
  	vector<int> res;
  	stack<int> s;
  	for (int i = nums.size()-1; i >= 0; --i) {
      		while (!s.empty() && s.top() <= nums[i]) {
            	s.pop();
          }
      		res[i] = s.empty() ? -1 : s.top();
      		s.push(nums[i]);
    }
  	return res;
}
```



# Hard
