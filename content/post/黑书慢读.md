---
title: "黑书慢读"
date: 2021-01-14T10:44:51+08:00
lastmod: 2021-01-14T10:44:51+08:00
draft: false
keywords: []
description: ""
tags: ["reading", "notes", "csapp", "sicp"]
categories: []
author: "lttzz"

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: true
postMetaInFooter: false
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: true
mathjaxEnableSingleDollar: true
mathjaxEnableAutoNumber: true

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams: 
  enable: false
  options: ""

---

别笑了别笑了，看完了看完了。

<!--more-->

# 深入理解计算机系统（csapp）

## 0x00 概述

$700$+​p，绝对的大部头，然而很适合大一大二这个样子读，建立起关于计算机的big picture ~~（不知道咋精准的翻译这个词组，看过MIT 18.06, Linear Algebra 的应该经常听到*Gilbert Strang* 提及）~~，对于之后的深入学习益处多多。

## 0x01 计算机系统漫游

## 0x02 信息的表示和处理

## 0x03 程序的机器级表示

### 概述

基于x86-64的ATT格式汇编，旨在教会读者看懂汇编，所以不同于王爽汇编的结构，没有很系统 ~~模式化~~ 的自底向上讲解汇编语法，而是从c语言代码生成汇编代码，自顶向下的讲解。

## 0x04 处理器体系结构

## 0x05 优化程序性能

程序性能的优化要考虑两个方面，一是编程语言级的，消除不必要的工作，如不必要的函数调用、条件测试和内存引用；二是在了解处理器运作的基础上，充分利用处理器提供的指令并行能力，同时执行多条指令。

研究程序的汇编代码表示，不断修改源代码，视图欺骗编译器以生成高效的机器指令是编写高性能程序的主要方式。

### 表示程序的性能

引入度量标准每元素的周期数（Cycle Per Element，CPE）。

![psum1 and psum2](/Picbed/2021_02/0202_03.png)

![cpe](/Picbed/2021_02/0202_02.png)

用最小二乘法拟合数据，$pusm1 : y = 368 + 9n$，$pusm2: y = 368 + 6n$，那么记pusm1和pusm2的CPE分别为 $9$ 和 $6$。（大 $O$ 记法里面的忽略掉的系数，粒度不同吧，CPE更精细些。

### 优化编译器的能力和局限性

#### Memory Aliasing

大多数的编译器，如GCC都提供了优化机制，从 $O0$ ~ $O3$ 优化等级逐渐升高，此外还有用来优化代码尺寸的$Os$。

实际上，编译器在进行优化的时候，也会遇到很多纠结的地方。

``` c
// 只从内存访问的角度看，twiddle1读*x两次，读*y两次，写*x两次，一共六次
void twiddle1(int *x, int *y)
{
    *x += *y;
    *x += *y;
}
// twiddle2读*x一次，读*y一次，写*x一次，一共三次
void twiddle2(int *x, int *y)
{
    *x += 2 * *y;
} 

// 那么是编译器否能将twiddle1优化成twiddle2呢？
// 不能的，这里涉及到的情况是内存别名使用
// 考虑 x==y 的情况，twiddle1最后的结果是增加后又增加，最后变成了四倍的原值
// twiddle2则是直接加了两倍，最后变成了三倍的原值
// 也就是说，twiddle1和twiddle2并不是等价的，并不能这样子优化
```

编译器的优化就这么辣鸡吗？不是。

``` c
#include <stdio.h>

void sum(int a, int b)
{
    int c = a + b;
}

int main(void)
{
    sum(1, 2);

    return 0;
}
```

猜猜GCC会如何优化呢？

``` assembly
; -O0
; 显然就是直接翻译了，传参、函数调用都有
0000000000001131 <main>:
    1131:	55                   	push   %rbp
    1132:	48 89 e5             	mov    %rsp,%rbp
    1135:	be 02 00 00 00       	mov    $0x2,%esi
    113a:	bf 01 00 00 00       	mov    $0x1,%edi
    113f:	e8 d5 ff ff ff       	callq  1119 <sum>
    1144:	b8 00 00 00 00       	mov    $0x0,%eax
    1149:	5d                   	pop    %rbp
    114a:	c3                   	retq   
    114b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    
; -O1
; ？？？？？
; 想想没毛病，主函数调用了一个没卵用的函数，直接优化掉好了
000000000000111a <main>:
    111a:	b8 00 00 00 00       	mov    $0x0,%eax
    111f:	c3                   	retq

; -O2
0000000000001020 <main>:
    1020:	31 c0                	xor    %eax,%eax
    1022:	c3                   	retq   
    1023:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    102a:	00 00 00 
    102d:	0f 1f 00             	nopl   (%rax)

; -O3
0000000000001020 <main>:
    1020:	31 c0                	xor    %eax,%eax
    1022:	c3                   	retq   
    1023:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    102a:	00 00 00 
    102d:	0f 1f 00             	nopl   (%rax)

; -Os
0000000000001020 <main>:
    1020:	31 c0                	xor    %eax,%eax
    1022:	c3                   	retq   
    1023:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    102a:	00 00 00 
    102d:	0f 1f 00             	nopl   (%rax)
    
; O2 和 O3 又采取了不同的优化思路（但我没看懂
; gdb 反汇编出来的是下面这样，能理解
Dump of assembler code for function main:
   0x0000000000001020 <+0>:	xor    eax,eax
   0x0000000000001022 <+2>:	ret 
```

可以看到，编译器会把“垃圾”优化掉。很棒哎，再看一个例子：

``` c
int x = 1000;
int y = 3000;
*q = y;			// 3000
*p = x;			// 1000
t1 = *q;		// 1000 or 3000
```

同样也是内存别名引用问题，q和p可能指向同一块内存所以并不能将第五行代码优化掉，虽然它“看起来”没啥子用，编译器会假定所有可能的情况都有可能发生。

类似的还有，C/C++学到指针哪一块的时候，很多老师爱举`swap()`的例子，然后嘞，有如下版本

``` c
#include <stdio.h>

int swap(int *x, int *y)
{
    *x = *x + *y;   // x+y
    *y = *x - *y;   // x+y-y = x
    *x = *x - *y;   // x+y-x = y
}

int main(void)
{
    int a = 1, b = 2;
    printf("a = %d, b = %d\n", a, b);
    swap(&a, &b);
    printf("a = %d, b = %d\n", a, b);

    return 0;
}

// $ ./a.out 
// a = 1, b = 2
// a = 2, b = 1
```

编译运行，`swap()`看起来没问题，但是当`swap(&a, &a)`呢？显然是把传进来的参数给清零了。说这个例子在于，内存别名引用的问题不光是会让编译器头疼。

#### 函数调用

除了内存别名引用，编译器优化过程中遇到的另一个问题是函数调用。

``` c
#include <stdio.h>

int counter = 0;

int f()
{
    return counter++;
}

int func1()
{
    return f() + f() + f() + f();
}

int func2()
{
    return 4 * f();
}

int main(void)
{
    // printf("func1: %d\n", func1());
    printf("func1: %d\n", func2());

    return 0;
}
```

是不能将`func1()`随意地优化成`func2()`的，尽管`func2()`性能会好得多。编译器依旧是假设了最糟糕的情况，即所有的函数都有副作用，并保持所有的函数调用关系不变。

C++引入了`inline`关键字，将是否优化（展开）的建议权交给程序员。

``` c++
// 编译参数： g++ counter.c -g -O1

// int f()
0000000000001139 <_Z1fv>:
    1139:	8b 05 f5 2e 00 00    	mov    0x2ef5(%rip),%eax        # 4034 <counter>
    113f:	8d 50 01             	lea    0x1(%rax),%edx
    1142:	89 15 ec 2e 00 00    	mov    %edx,0x2eec(%rip)        # 4034 <counter>
    1148:	c3                   	retq   
0000000000001149 <_Z5func1v>:
    1149:	53                   	push   %rbx
    114a:	e8 ea ff ff ff       	callq  1139 <_Z1fv>
    114f:	89 c3                	mov    %eax,%ebx
    1151:	e8 e3 ff ff ff       	callq  1139 <_Z1fv>
    1156:	01 c3                	add    %eax,%ebx
    1158:	e8 dc ff ff ff       	callq  1139 <_Z1fv>
    115d:	01 c3                	add    %eax,%ebx
    115f:	e8 d5 ff ff ff       	callq  1139 <_Z1fv>
    1164:	01 d8                	add    %ebx,%eax
    1166:	5b                   	pop    %rbx
    1167:	c3                   	retq   
0000000000001168 <_Z5func2v>:
    1168:	e8 cc ff ff ff       	callq  1139 <_Z1fv>
    116d:	c1 e0 02             	shl    $0x2,%eax
    1170:	c3                   	retq 

// inline int f()
// 可以看到，f()的机器码被复制到了func1和func2中
// 在func2里，替换掉了函数调用
// 在func1里，不光展开了，还进行了一定的优化
0000000000001139 <_Z5func1v>:
    1139:	8b 05 f5 2e 00 00    	mov    0x2ef5(%rip),%eax        # 4034 <counter>
    113f:	8d 50 04             	lea    0x4(%rax),%edx
    1142:	89 15 ec 2e 00 00    	mov    %edx,0x2eec(%rip)        # 4034 <counter>
    1148:	8d 04 85 06 00 00 00 	lea    0x6(,%rax,4),%eax
    114f:	c3                   	retq   

0000000000001150 <_Z5func2v>:
    1150:	8b 05 de 2e 00 00    	mov    0x2ede(%rip),%eax        # 4034 <counter>
    1156:	8d 50 01             	lea    0x1(%rax),%edx
    1159:	89 15 d5 2e 00 00    	mov    %edx,0x2ed5(%rip)        # 4034 <counter>
    115f:	c1 e0 02             	shl    $0x2,%eax
    1162:	c3                   	retq
```

### 优化程序性能

#### 例子

``` c
// 未经过优化的原始代码
void combine1(vec_ptr v, data_t *dest)
{
    *dest = IDENT;
    for (int i = 0; i < vec_length(v); ++i)
    {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OP val;
    }
}

// 通过代码移动（code motion），消除低效的循环
void combine2(vec_ptr v, data_t *dest)
{
    *dest = IDENT;
    int len = vec_length(v);
    for (int i = 0; i < len; ++i)
    {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OP val;
    }
}

// 消除循环体内函数调用
// （然鹅性能并没有变化，甚至稍稍差了些，这又是另外的影响因素了（不必要的内存引用问题
dest_t *get_vec_start(vec_ptr v)
{
    return v->data;
}
void combine3(vec_ptr v, data_t *dest)
{
    int len = vec_length(v);
    data_t *data = get_vec_start(v);
    *dest = IDENT;
    for (int i = 0; i < len; ++i)
    {
        *dest = *dest OP data[i];
    }   
} 

// 减少不必要的内存引用
void combine4(vec_ptr v, data_t *dest)
{
    int len = vec_length(v);
    data_t *data = get_vet_start(v);
    data_t acc = IDENT;
    for (int i = 0; i < len; ++i)
    {
        acc = acc OP data[i];
    }
    *dest = acc;
}
```

#### 消除低效的循环

``` c
#include <stdio.h>

size_t strlen(const char *s)
{
    long len = 0;
    while (*s != '\0')
    {
        s++;
        len++;
    }
    return len;
}

void lower1(char *s)
{
    for (int i = 0; i < strlen(s); ++i)
    {
        if (s[i] >= 'A' && s[i] <= 'Z')
            s[i] -= ('A' - 'a');
    }
}

void lower2(char *s)
{
    int len = strlen(s);
    for (int i = 0; i < len; ++i)
    {
        if (s[i] >= 'A' && s[i] <= 'Z')
            s[i] -= ('A' - 'a');
    }
}

int main(void)
{
    char s[10] = "LALALALA";
    lower1(s);
    printf("%s\n", s);

    return 0;
}
```

经典例子了，以前真的都是按`lower1()`写的 ~~，理由嘛，觉得写局部变量挺不好看的~~，😅。

![lower1 VS lower2](/Picbed/2021_02/0201_01.png)

#### 减少过程调用

见例子中的 `combine2()` => `combine3()` 。

#### 消除不必要的内存引用

![combine2 VS combine3](/Picbed/2021_02/0201_02.png)

`combine3()` 明明减少了过程调用，为什么性能没有提升呢？

``` assembly
; Inner loop of combine3. data_t = double, OP = *
; dest in %rbx, data+i in %rdx, data+length in %rax

1	.L17:								; loop:
2		vmovsd (%rbx), %xmm0			;	Read product from dest
3		vmulsd (%rdx), %xmm0, %xmm0		; 	Multiply product by data[i]
4		vmovsd %xmm0, (%rbx)			; 	Store product at dest
5		addq $8, %rdx					;	Increment data+i
6		cmpq %rax, %rdx					;	Compare to data+length
7		jne .L17						; 	if != , goto loop
```

$2$ ～ $3$ 行循环体内将数据读出、计算、写回，实际上没有必要，上一次写入的数就是这一次要读出的数，也就是说 `combine3()` 性能没达到预期是内存引用造成的。

解决不必要的内存引用，可以采取引入用以累积计算值的临时变量，在循环完成后，再将结果写入到内存中。

``` assembly
; Innver loop of combine4, data_t = double, OP = *
; acc in %xmm0, data+i in %rdx, data+length in %rax
1	.L25:								; loop:
2		vmulsd (%rdx), %xmm0, %xmm0		;	Multiply acc by data[i]
3		addq $8, %rdx					;	Increment data+i
4		cmpq %rax, %rdx					; 	Compare to data+length
5		jne .L25						; 	if != , goto loop
```

![combine3 VS combine4](/Picbed/2021_02/0202_00.png)

那么，编译器是否应该足够优秀到可以将 `combine3()` 优化成 `combine4()` 呢？

不能，同样是内存别名引用问题，当 `dest = get_vec_start(v) + get_vec_length(v)` 时，`combine3()` 和 `combine4()` 的结果是不同的，实际上 `combine4()` 才是符合预期功能的，问题是编译器不知道程序员写下这段代码的意图，所以采取“直译”的方式，不加改动。

如果非要让编译器优化呢？当对 `combine3()` 开 $O2$ 优化时，性能依旧会比 $O1$ 好得多，其生成的指令如下：

``` assembly
; Innver loop of combine3, data_t = double, OP = *
; dest in $rbx, data+i in %rdx, data+length in %rax
; Accumulated product in %xmm0
1	.L22:								; loop:
2		vmulsd (%rdx), %xmm0, %xmm0		;	Multiply product by data[i]
3		addq $8, %rdx					;	Increment data+i
4		cmpq %rax, %rdx					; 	Compare to data+length
5		vmovsd %xmm0, (%rbx)			; 	Store product at dest
6		jne .L25						; 	if != , goto loop
```

![combine3w](/Picbed/2021_02/0202_01.png)

和`combine4()` 挺接近了，但还是忠实的实现了`combine3()`的C语言代码。

``` c
// 减少不必要的内存引用
void combine3w(vec_ptr v, data_t *dest)
{
    int len = vec_length(v);
    data_t *data = get_vet_start(v);
    data_t acc = IDENT;
    *dest = acc;
    for (int i = 0; i < len; ++i)
    {
        acc = acc OP data[i];
        *dest = acc;
    }
}
```

不得不说，指针有利也有弊。

### 循环展开

好处有二：一是减少了条件测试，二是展开有利于编译器进行优化。

``` c++
// 2x1 展开
void combine5(vec_ptr v, data_t *dest)
{
    long len = vec_length(v);
    long limit = len - 1;
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;

    int i = 0;
    for (int i = 0; i < limit; i+=2)
    {
        acc = (acc OP data[i]) OP data[i+1];
    }
    for ( ; i < len; ++i)
    {
        acc = acc OP data[i];
    }
    *dest = acc;
}
```

![combine4 VS combine5](/Picbed/2021_02/0202_06.png)

### 提高并行性

#### 多个累计变量

``` c++
// 2x2 展开
void combine6(vec_ptr v, data_t *dest)
{
    long len = vec_length(v);
    long limit = len - 1;
    data_t *data = get_vec_start(v);
    data_t acc0 = IDENT;
    data_t acc1 = IDENT;

    int i = 0;
    for (int i = 0; i < limit; i+=2)
    {
        acc0 = acc0 OP data[i];
        acc1 = acc1 OP data[i+1];
    }
    for ( ; i < len; ++i)
    {
        acc0 = acc0 OP data[i];
    }
    *dest = acc0 OP acc1;
}
```

![combine5 VS combine6](/Picbed/2021_02/0202_07.png)

指令并行在CPE 的表现就是突破延迟界限，当然吞吐量界限突破不了。

### 理解现代处理器

前面说到的优化程序性能是硬件无关的，想要进一步提高程序性能，必须要考虑处理器微体系结构的优化，也就是处理器用来执行指令的底层系统设计。

这里会遇到两个限制程序性能的界限，一是延迟界限（latency bound），诸如数据相关等限制处理器并行能力的情况，能够影响到程序性能，二是吞吐量界限（throughput bound），这是刻画处理器功能单元原始计算能力的，是程序性能的根本限制。

拿前面最后的优化版本`combine4()`举例：

![latency bound and throughput bound](/Picbed/2021_02/0202_04.png)

又来了一个经典的例子，多项式求值。
$$
a_{0} + a_{1}x + a_{2}x^{2}+ ... + a_{n}x^{n}
$$

``` c
// 常规求和
double poly(vector<double> a, double x, long degree)
{
    double result = a[0];
    double xpwr = x;
    for (long i = 1; i <= degree; ++i)
    {
        result += a[i] * xpwr;		// 一次浮点加法一次浮点乘法
        xpwr = x * xpwr;			// 一次浮点乘法
    }
    return result;
}

// 秦九韶算法
double polyh(vector<double> a, double x, long degree)
{
    double result = a[degree];
    for (long i = degree-1; i >= 0; --i)
    {
        result = a[i] + x * result;		// 一次浮点加法一次浮点乘法
        // 数据相关，所以 CPE = 3 + 5 = 8
    }
    return result;
}
```

![poly](/Picbed/2021_02/0202_05.png)

csapp在假定如下性能参数的情况下，得到 `poly()` CPE为5，`polyh()` CPE为8，即后者性能不如前者。

首先浮点乘法单元是有两个的，那么 `a[i] * xpwr` 和 `x * xpwr` 可以并行计算，而对于 `result` 的更新时间为啥没了，这就是流水线的功劳了。

### 总结

+ 高级设计：选择合适的算法和数据结构
+ 基本编码原则：避免限制优化的因素，使编译器生成高效的代码
  + 消除连续的函数调用
  + 消除不必要的内存引用：引入中间变量，只在最后将结果更新到数组等用到内存引用的地方
+ 低级优化
  + 展开循环（kx1展开）
  + 使用多个累计变量（1xk展开）和重新结合等技术
  + 用功能性的风格重写条件操作：少用数据控制，多用数据传送

# 计算机程序的构造和解释（sicp）

# 剑指Offer

## chap1 面试

## 技术面

+ 编程语言、数据结构和算法
+ 代码质量很重要，要关注边界条件和特殊输入（空指针、空字符串等）以及错误处理
+ 画图使抽象问题形象化，举例使抽象问题具体化，分解使复杂问题简单化

## chap2 基础知识

### 01 xx函数

为 MyString 类添加赋值运算函数。

``` c++
public:
  	MyString(char *pData = nullptr);
    MyString(const MyString &str);
  	MyString& operator = (const MyString &rhs);	// 声明
    ~MyString(void);
  
private:
  	char *m_pData;
}

// 实现
// 返回类型声明为引用，以实现连续赋值，参数声明为 const reference，避免值传递的开销
MyString& MyString::operator = (const MyString &rhs)
{
  	if (this != rhs) {
      	MyString objTemp(rhs);
      	
      	// 原有数据和栈上的自动变量交换，故而不需要关心内存释放问题
      	char *pTemp = objTemp.m_pData;
      	objTemp.m_pData = m_pData;
      	m_pData = pTemp;
    }
  
  	return *this;
}
```

### 02 实现单例模式

``` c++
singleton
```

### 09 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

[leetcode](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

思路：题意是把先进后出的栈改造成先进先出的队列，实现入队和出队操作。如果是一次性连续入队后一次性连续出队，那么一个栈倒腾到另一个栈就完成了，但此处并没有指明操作序列。实际上分治的想一想，可以将整个的操作序列用出队操作分割成一个个小操作序列，每个操作序列都满足刚刚很容易实现的条件。

总的来说：压栈只管压入stk1，出栈的时候，如果stk2空，说明这是一个新的小操作序列，stk1中的内容全部出栈并压入stk2中。倒腾完了，stk2要么非空，要么还是空的，如果是空的，说明整个队列就是空的呀，异常处理或者放回一个约定表示队列空的值；如果stk2非空，栈顶元素出栈并返回即可。

``` c++
#include <iostream>
#include <stack>

using namespace std;

class CQueue {
public:
    CQueue() { }

    void appendTail(int value)
    {
        stk1.push(value);
    }

    int deleteHead()
    {
        // 删除操作的时候，如果stk2空，则stk1全部出栈并压入stk2
        // 如果此时stk2不空，则栈顶出栈，否则表明“队列”为空
        if (stk2.empty()) {
            while (!stk1.empty()) {
                stk2.push(stk1.top());
                stk1.pop();
            }
        }

        if (stk2.empty()) {
            return -1;
        } else {
            int tmp = stk2.top();
            stk2.pop();
            return tmp;
        }
    }

private:
    stack<int> stk1, stk2;
};

int main()
{
    CQueue* q = new CQueue();
    q->appendTail(2);
    q->appendTail(3);
    q->appendTail(4);
    cout << q->deleteHead() << endl;
    cout << q->deleteHead() << endl;
    cout << q->deleteHead() << endl;
    cout << q->deleteHead() << endl;
    cout << q->deleteHead() << endl;

    return 0;
}
```

